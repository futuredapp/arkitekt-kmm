{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#arkitekt-kmm","title":"Arkitekt KMM","text":"<p>Arkitekt KMM is a Kotlin Multiplatform Mobile library that helps you with the abstraction of a use cases, known as one of the building blocks of the Clean Architecture. Its main objective is a separation of concerns and better domain modeling. It is backed by <code>Kotlin Coroutines</code>.</p>"},{"location":"#benefits","title":"Benefits","text":"<ul> <li>Delegate work to a background thread</li> <li>Cancel on re-execution (optional)</li> <li>Error handling</li> <li>Auto-cancellation when is the related coroutine scope terminated</li> </ul>"},{"location":"#content","title":"Content","text":"<p>The module <code>km-usecases</code> provides two main components - <code>UseCase</code> and <code>FlowUseCase</code>:</p> <ul> <li><code>UseCase</code> is for events that return a single response (e.g. REST API call GET, POST...).</li> <li><code>FlowUseCase</code> is for events that return multiple responses (e.g. Location data updates...).</li> </ul> <p>Another module, <code>km-viewmodel</code> consists <code>ArktitektViewModel</code> which will help with maintaining  <code>CoroutineScope</code> on iOS platform:</p> <ul> <li><code>ArktitektViewModel</code> creates <code>CoroutineScope</code> and manages it</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Head out to Installation section.</p>"},{"location":"#example","title":"Example","text":"<p>Check out the usage in the example.</p>"},{"location":"docs/ArkitektViewModel/","title":"ArkitektViewModel","text":""},{"location":"docs/Overview/installation/","title":"Installation","text":""},{"location":"docs/Overview/installation/#setup-project","title":"Setup project","text":"<p>Arkitekt-KMM is a Kotlin Multiplatform Mobile library, so you have to use it in KMM project. First, add sonatype repository to your project <code>build.gradle.kts</code> as this library is currently  available as a snapshot:</p> <pre><code>// project root build.gradle.kts\nbuildscript {\nrepositories {\ngradlePluginPortal()\ngoogle()\nmavenCentral()\n}\ndependencies {\nclasspath(...)\n}\n}\n\nallprojects {\nrepositories {\ngoogle()\nmavenCentral()\n// sonatype repository for snapshots\nmaven { setUrl(\"https://oss.sonatype.org/content/repositories/snapshots/\") }\n}\n}\n</code></pre> <p>Second, add the dependency to your <code>shared/build.gradle.kts</code> as a <code>commonMain</code> dependency. We recommend to add it as <code>api</code> configuration instead of <code>implementation</code> as it will expose the library for the  Android app. We also recommend to add <code>km-viewmodel</code> to <code>iosMain</code> as well as it makes usage on iOS easier and more convenient.</p>"},{"location":"docs/Overview/installation/#setup-shared-module","title":"Setup shared module","text":"<pre><code>// shared module build.gradle.kts\nkotlin {\nios()\nandroid()\nsourceSets {\nval commonMain by getting {\ndependencies {\n// Arkitekt usecases\napi(\"app.futured.arkitekt:km-usecases:0.1.1-SNAPSHOT\")\n}\n}\nval androidMain by getting {\ndependencies {\n...\n}\n}\nval iosMain by getting {\ndependencies {\napi(\"app.futured.arkitekt:km-viewmodel:0.1.2-SNAPSHOT\")\n}\n}\n}\n}\n</code></pre>"},{"location":"docs/Overview/installation/#usage","title":"Usage","text":"<p>Now you are all set up, head to the Usage section.</p>"},{"location":"docs/UseCases/","title":"UseCases","text":""},{"location":"docs/UseCases/#usage","title":"Usage","text":""},{"location":"docs/UseCases/FlowUseCase/","title":"FlowUseCase usage","text":""},{"location":"docs/UseCases/FlowUseCase/#define-flowusecase","title":"Define FlowUseCase","text":"<p>FlowUseCase is a abstract class with one abstract function. It has two generic parameters. The first is to define Argument type, the second is to define Return type. FlowUseCase will always return a flow of defined return type. The flow will be executed on non-ui thread. Don't forget to <code>freeze()</code> the FlowUseCase in <code>init</code> block. Any properties has to be initialized/injected above the init block because of freezing.</p> <pre><code>// shared/src/commonMain/../domain/\nclass ObserveCoinsUseCase : FlowUseCase&lt;Unit, List&lt;Coin&gt;&gt;() {\nprivate val coinStore: CoinStore = CoinStore(RestApiManager, DatabaseManager)\n\ninit {\nfreeze()\n}\n\noverride fun build(arg: Unit): Flow&lt;List&lt;Coin&gt;&gt; {\nprintln(\"ObserveCoinsUseCase building...\")\nreturn coinStore.observeCoins()\n}\n\n}\n</code></pre> <p>Note that only the flow will be executed on non-ui thread. The rest of the <code>build</code> function will be executed on UI thread.</p>"},{"location":"docs/UseCases/FlowUseCase/#execute-flowusecase","title":"Execute FlowUseCase","text":"<p>To be able to execute the FlowUseCase you have to be in the scope of <code>CoroutineScopeOwner</code>. On the Android side you can take advantage of <code>viewModelScope</code> from Android Architecture Components (AAC). On the iOS side you can use <code>ArkitektViewModel</code>from <code>km-viewmodel</code>. If you need to execute the FlowUseCase outside of ViewModel, e.g. in a Service, you need to implement <code>CoroutineScopeOwner</code> and provide <code>CoroutineScope</code> by yourself.</p>"},{"location":"docs/UseCases/FlowUseCase/#usage-on-android","title":"Usage on Android","text":"<p>Define a BaseViewModel:</p> <pre><code>// androidApp\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport app.futured.arkitekt.kmusecases.scope.CoroutineScopeOwner\n\nabstract class BaseViewModel : ViewModel(), CoroutineScopeOwner {\n\noverride val coroutineScope = viewModelScope\n}\n</code></pre> <p>Execute the UseCase:</p> <pre><code>class CoinsViewModel : BaseViewModel() {\nprivate val observeCoinsUseCase = ObserveCoinsUseCase()\n\nvar coins by mutableStateOf(emptyList&lt;Coin&gt;())\nvar isLoading by mutableStateOf(false)\n\nfun fetchCoins() {\nobserveCoinsUseCase.execute(Unit) {\nonStart { isLoading = true }\nonNext { coins = it\nisLoading = false\n}\nonError {\nisLoading = false    println(it.message)\n}\n}\n}\n}\n</code></pre>"},{"location":"docs/UseCases/FlowUseCase/#usage-on-ios","title":"Usage on iOS","text":"<pre><code>// iosApp\nimport shared\n\nclass BaseViewModel : Km_viewmodelArkitektViewModel {\n\n    deinit {\n        onDestroy()\n    }\n}\n</code></pre> <p>Execute the UseCase:</p> <pre><code>// iosApp\nimport shared\n\nclass CoinsViewModel : BaseViewModel, ObservableObject {\n    @Published var coins = [Coin]()\n\n    private let getCoinsUseCase = GetCoinsListUseCase()\n\n    func getCoins() {\n        getCoinsUseCase.execute(self, args: KotlinUnit()) {\n            $0.onSuccess { list in\n                self.coins = list as [Coin]\n            }\n            $0.onError { error in\n                print(error)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"docs/UseCases/FlowUseCase/#usecase-usage","title":"UseCase usage","text":"<p>Head out to UseCase section.</p>"},{"location":"docs/UseCases/FlowUseCase/#example","title":"Example","text":"<p>Check out the usage in the example</p>"},{"location":"docs/UseCases/UseCase/","title":"UseCase usage","text":""},{"location":"docs/UseCases/UseCase/#define-usecase","title":"Define UseCase","text":"<p>UseCase is a abstract class with one abstract suspend function. It has two generic parameters. The first is to define  Argument type, the second is to define Return type. If you don't need any of these, just put in z <code>Unit</code> The suspend function will be executed on non-ui thread. Don't forget to <code>freeze()</code> the UseCase in <code>init</code> block.  Any properties has to be initialized/injected above the init block because of freezing.</p> <pre><code>// shared/src/commonMain/../domain/\nclass GetCoinsListUseCase : UseCase&lt;Unit, List&lt;Coin&gt;&gt;() {\nprivate val coinStore: CoinStore = CoinStore(RestApiManager, DatabaseManager)\n\ninit {\nfreeze()\n}\n\noverride suspend fun build(arg: Unit): List&lt;Coin&gt; {\nval list = coinStore.fetchCoins().coins.map {\nCoin(it.id, it.name, it.icon, it.symbol, it.price)\n}\nreturn list\n}\n}\n</code></pre>"},{"location":"docs/UseCases/UseCase/#execute-usecase","title":"Execute UseCase","text":"<p>To be able to execute the UseCase you have to be in the scope of <code>CoroutineScopeOwner</code>. On the Android side you can take advantage of <code>viewModelScope</code> from Android Architecture Components (AAC). On the iOS side you can use <code>ArkitektViewModel</code>from <code>km-viewmodel</code>. If you need to execute the UseCase outside of ViewModel,  e.g. in a Service, you need to implement <code>CoroutineScopeOwner</code> and provide <code>CoroutineScope</code> by yourself.</p>"},{"location":"docs/UseCases/UseCase/#usage-on-android","title":"Usage on Android","text":"<p>Define a BaseViewModel:</p> <pre><code>// androidApp\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport app.futured.arkitekt.kmusecases.scope.CoroutineScopeOwner\n\nabstract class BaseViewModel : ViewModel(), CoroutineScopeOwner {\n\noverride val coroutineScope = viewModelScope\n}\n</code></pre> <p>Execute the UseCase:</p> <pre><code>// androidApp\nclass CoinsViewModel : BaseViewModel() {\nprivate val getCoinsUseCase = GetCoinsListUseCase()\n\nvar coins by mutableStateOf(emptyList&lt;Coin&gt;())\nvar isLoading by mutableStateOf(false)\n\nfun fetchCoins() {\ngetCoinsUseCase.execute(Unit) {\nonStart { isLoading = true }\nonSuccess { coins = it\nisLoading = false\n}\nonError {\nisLoading = false    println(it.message)\n}\n}\n}\n}\n</code></pre>"},{"location":"docs/UseCases/UseCase/#usage-on-ios","title":"Usage on iOS","text":"<pre><code>// iosApp\nimport shared\n\nclass BaseViewModel : Km_viewmodelArkitektViewModel {\n\n    deinit {\n        onDestroy()\n    }\n}\n</code></pre> <p>Execute the UseCase:</p> <pre><code>// iosApp\nimport shared\n\nclass CoinsViewModel : BaseViewModel, ObservableObject {\n    @Published var coins = [Coin]()\n\n    private let getCoinsUseCase = GetCoinsListUseCase()\n\n    func getCoins() {\n        getCoinsUseCase.execute(self, args: KotlinUnit()) {\n            $0.onSuccess { list in\n                self.coins = list as [Coin]\n            }\n            $0.onError { error in\n                print(error)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"docs/UseCases/UseCase/#flowusecase-usage","title":"FlowUseCase usage","text":"<p>Head out to FlowUseCase section.</p>"},{"location":"docs/UseCases/UseCase/#example","title":"Example","text":"<p>Check out the usage in the example</p>"}]}